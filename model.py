import streamlit as st
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
from datetime import date, timedelta
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf
from statsmodels.tsa.statespace.sarimax import SARIMAX
import statsmodels.api as sm
import warnings
from statsmodels.tools.sm_exceptions import ConvergenceWarning

warnings.simplefilter('ignore', ConvergenceWarning)


# App title
st.set_page_config(
    page_title="Ethereum ARIMA Forecast",
    page_icon="💹"
)
st.title("Ethereum Price Forecast (ARIMA Model)")

# Define symbol and date range
today = date.today()
end_date = today.strftime("%Y-%m-%d")
start_date = (today - timedelta(days=365)).strftime("%Y-%m-%d")

# Fetch Data
@st.cache_data
def load_data():
    return yf.download("ETH-USD", start=start_date, end=end_date) 

# Call the function and assign to df
df = load_data()

# This method is used for Column Arrange due Except Date Column Every Column showing row with  "ETH-USD"
if isinstance(df.columns, pd.MultiIndex):
    df.columns = [col[0] for col in df.columns]

# Arrange columns and Add Date column at the palce of index
df["Date"] = df.index
df.reset_index(drop=True, inplace=True)
df = df[['Date', 'Close', 'High', 'Low', 'Open', 'Volume']]
print(df.head())  # This is used to confirm data it is fetch correctly.


# # Show Raw Data and get input for prediction
st.subheader("Historical Close Prices")
st.line_chart(df['Close'])

n_days = st.number_input(
    label="Select number of days to forecast",
    min_value=1,
    max_value=30,
    value=7,
    step=1
)

# Description
st.subheader("Forecast Disclaimer")
st.markdown(
    """
    Our 30-day Ethereum price projection is generated by an ARIMA model trained on the past year of daily closing prices. While this approach captures recent trends, seasonal patterns, and autocorrelations, cryptocurrency markets remain highly sensitive to breaking news, regulatory shifts, and sudden macroeconomic events. As a result, the forecast should be viewed as an informed estimate rather than a guaranteed outcome—actual prices may diverge as new information and market dynamics unfold.
    """
)

# Check data is stationary or not.
def adf_test(series):
    result = adfuller(series.dropna())  # drop NaNs to avoid issues
    print('ADF Statistic  : %f' % result[0])
    print('p-value        : %f' % result[1])
    if result[1] <= 0.05:
        print("✅ Data is Stationary (reject H0)")
    else:
        print("❌ Data is NOT Stationary (fail to reject H0)")


# # Run the test
adf_test(df['Close'])


# Decomposing the data to see the Trend , Seasonality and Noise
# decompose = seasonal_decompose(df['Close'], model='additive', period=30)
# decompose.plot()
# plt.savefig("Data/Trends_Seasonality.png", bbox_inches="tight")
# plt.close

# Create a figure and axes (3 rows, 2 columns)
fig, axes = plt.subplots(3, 2, figsize=(12, 8), sharex=True)

# Plot original series
axes[0, 0].plot(df['Close'])
axes[0, 0].set_title('Original Series')
plot_acf(df['Close'], ax=axes[0, 1])

# # 1st order differencing
axes[1, 0].plot(df['Close'].diff())
axes[1, 0].set_title('1st Order Differencing')
plot_acf(df['Close'].diff().dropna(), ax=axes[1, 1])

# # 2nd order differencing
axes[2, 0].plot(df['Close'].diff().diff())
axes[2, 0].set_title('2nd Order Differencing')
plot_acf(df['Close'].diff().diff().dropna(), ax=axes[2, 1])

# Save figure
# plt.tight_layout()
# plt.savefig("Data/1st_&_2nd_order_Differencing.png", bbox_inches="tight")
# plt.close()

# After take a look at fig D value is assumed 1

# Lets Find P value
# pd.plotting.autocorrelation_plot(df['Close'])
# plot_acf(df['Close'], alpha=0.05)
# x_acf = pd.DataFrame(acf(df['Close']))
# print(x_acf)
# plt.tight_layout()
# plt.savefig("Data/autocorrelation_plot.png", bbox_inches="tight")
# plt.close()

# Now After finding how many index which are greater then 0.95 P = 3

# Lets Find out q Value
# plot_pacf(df['Close'], lags=20, alpha=0.05)
# plt.tight_layout()
# plt.savefig("Data/q_value.png", bbox_inches="tight")
# plt.close()

# # Now Q = 2 after checking from fig how many is less then 0.95
d = 1
p = 3
q = 2
# Lets Use Sarima
@st.cache_resource
def train_sarima_model(data, order, seasonal_order):
    model = sm.tsa.statespace.SARIMAX(
        data, order=order, seasonal_order=seasonal_order
    )
    return model.fit()

# Use the function
model = train_sarima_model(df['Close'], order=(p, d, q), seasonal_order=(p, d, q, 12))

# Show forecast plot
st.subheader("Forecasted Prices with Confidence Intervals")

# Forecast n_days ahead
prediction = model.predict(
    start=len(df['Close']),
    end=len(df['Close']) + n_days
)

fig, ax = plt.subplots(figsize=(12, 7))
ax.plot(df['Close'],       label="Historical")
ax.plot(prediction, color='red', label="Forecast")
ax.fill_between(
    prediction.index,
    prediction.values * 0.95,  # approximate 95% bounds if available
    prediction.values * 1.05,  # replace with actual CI when using get_forecast()
    color='red', alpha=0.3,
    label="95% CI"
)
ax.set_title(f"Next {n_days}-Day ETH-USD Price Prediction")
ax.set_xlabel("Date")
ax.set_ylabel("Close Price (USD)")
ax.legend(loc='upper left')
st.pyplot(fig)
